注意 在树的递归中
使用了 if root.left:
         xxx
      if root.right:
         xxx
这样的话在最前面一定要有一个判断，即if root is None:
                                    return


注意，其实
path.append(xx)
for i in range(size):
    dfs(xx)
path.pop()
等同于
for i in range(size):
    path.append(xx)
    dfs(xx)
    path.pop()
只不过可能在下面这种方式中，有时候需要用到i,所以需要写成这样
有个例题比如79题，这个题就可以将回溯中的路径选择弄到外面

注意在回溯中
全排列2问题中，i>0是为了nums[i-1] == nums[i]可以进行比较
在子集2问题中，i>start之后进行nums[i-1] == nums[i],此时i>start可以确保是在当前节点的第二条路下



注意200题和994题目的区别：
200题需要遍历网格中的每一个节点，所以一开始遍历的时候就要先将头节点的marked标记为True
994题第一次已经将所有的烂橘子都入队列了

在全排列的题目中，起点其实是一个空列表[]，所以这个时候按回溯模板递归，在for i in range(len)内部进行标记判断和进行路径选择等等
在二维图中，需要遍历每一个点，所以这个时候可以在外部两层for循环中先将marked标记为true，然后在pop
          然后在dfs中进行标准的操作，append dfs pop
在二维图中，也可以直接在DFS中进行判断，在dfs总的for循环上面进行标记，然后在内部判断新的点是否被标记，for循环结束之后需要pop



经常把 == 和 = 弄混导致错误！！！！
需要打断点看！


74题中，二维变成一维的方法
matrix[mid // col][mid % col]
