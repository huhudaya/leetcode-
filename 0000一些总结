注意 在树的递归中
使用了 if root.left:
         xxx
      if root.right:
         xxx
这样的话在最前面一定要有一个判断，即if root is None:
                                    return


注意，其实
path.append(xx)
for i in range(size):
    dfs(xx)
path.pop()
等同于
for i in range(size):
    path.append(xx)
    dfs(xx)
    path.pop()
只不过可能在下面这种方式中，有时候需要用到i,所以需要写成这样
有个例题比如79题，这个题就可以将回溯中的路径选择弄到外面


注意在回溯中
全排列2问题中，i>0是为了nums[i-1] == nums[i]可以进行比较
在子集2问题中，i>start之后进行nums[i-1] == nums[i],此时i>start可以确保是在当前节点的第二条路下



注意200题和994题目的区别：
200题需要遍历网格中的每一个节点，所以一开始遍历的时候就要先将头节点的marked标记为True
994题第一次已经将所有的烂橘子都入队列了

在全排列的题目中，起点其实是一个空列表[]，所以这个时候按回溯模板递归，在for i in range(len)内部进行标记判断和进行路径选择等等
在二维图中，需要遍历每一个点，所以这个时候可以在外部两层for循环中先将marked标记为true，然后在pop
          然后在dfs中进行标准的操作，append dfs pop
在二维图中，也可以直接在DFS中进行判断，在dfs总的for循环上面进行标记，然后在内部判断新的点是否被标记，for循环结束之后需要pop



经常把 == 和 = 弄混导致错误！！！！
需要打断点看！


74题中，二维变成一维的方法
matrix[mid // col][mid % col]


在子集中:
if start < i and nums[i] == nums[i - 1]:
# 这里的 i 是指回溯树中同一层（当前层）中的其他节点，start指层数
'''
          start i
for i in  1     2 3 4
for i in  2     3 4
for i in  3     4
for i in  4
'''
当限制了 i>start
之后因为每次递归的时候都是i+1,所以每一层的第一个和上一层的第一个都不会相同，所以不会出现子集112那种情况

在全排列中
这里的 i 为每一层中的第i个元素，i>0 只是为了判断 i-1 的值
used[i - 1]中的i-1是同一层中的i的前一个节点，这里要确保used[i-1]是False
则证明i-1是刚刚遍历过的，同一层再次出现相同的元素就continue
避免下一层第元素和上一层中的元素一样时也被误kill
比如 112
1
1
2
第一层中的1，和下一层中的元素相同，因为全排列没有取 start=i+1 这种操作，所以要避免出现这种情况

if i > 0 and nums[i] == nums[i - 1] and used[i - 1] is False:
这这里如果排完序之后，则num[i] 和 num[i-1]是同一层中相邻的两个元素

总结
其实i在行和列方向上都是增加的
    i+1
i+1 1   2   3
    2   3
    3


在轴上有交点！！！
比如在X轴有交点 看投影
设(a,b)是从 a 点到 b 点的一个线段
即 A(x1,x2)   B(x3,x4)
如果线段A和B有交集
则需要
min(A[1],B[1]) > max(A[0],B[0])   !!!!!请牢记 两点最大值的最小值必须大于两点最小值的最大值！！！！！！！


如果在树，回溯，等递归中：
    如果在子条件判断了比如if root.left:
                        xxx
    这样只需要在最上面判断一下if root.left and root.right:
    不需要先判断if root:
    可以在递归函数外进行一次判断就可以