'''
根据 百度百科 ，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机

给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。
每个细胞都具有一个初始状态：1 即为活细胞（live），或 0 即为死细胞（dead）
每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：

如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡
如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活
如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡
如果死细胞周围正好有三个活细胞，则该位置死细胞复活
根据当前状态，写一个函数来计算面板上所有细胞的下一个（一次更新后的）状态
下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的
示例：
输入：
[
  [0,1,0],
  [0,0,1],
  [1,1,1],
  [0,0,0]
]
输出：
[
  [0,0,0],
  [1,0,1],
  [0,1,1],
  [0,1,0]
]
进阶：
你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。
本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。你将如何解决这些问题？

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/game-of-life
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
'''


'''
总结：类似的矩阵问题有很多，但不管什么问题，有两个技巧是一定用的上的，一定要记住！！！

1、矩阵中某个位置的状态如果发生改变，那么这种题的解法一般是两次遍历整个矩阵。第一遍遍历时，用一个不可能出现在原矩阵中的中间值来保存状态的变化（这样在此次遍历时，不影响其他的位置的判断，比如我们可以用“$”这种没人用的字符）；第二遍遍历时，把中间值刷新成为变化后应该变成的值。

2、如果遍历到某个位置时，需要查看它周边的位置，此时如果每一个周围的位置都手写，然后再判断是否越界，就很麻烦。可以先用一个数组保存向周边位置变化的坐标偏移值，一次性通过一个循环，来遍历完周边的位置，并且方便进行越界判断。

分析本题：
本题就是上面两个技巧的典型用例，因为所有的格子同时刷新变化，所以，你需要两次遍历
第一次遍历时，判断下一次刷新后的状态应该是啥，你要记下变化
但你又不能影响本次正在进行的遍历，所以你可以用一个中间值来记录。第二次遍历时，刷新中间值
'''
'''
class Solution {
    public void gameOfLife(int[][] board) {
        // 对应技巧2，用一个长度为8的数组来保存遍历每一个位置时，其周边位置的相对坐标偏移
        int[] x = {0, 0, 1, 1, 1, -1, -1, -1};
        int[] y = {1, -1, 1, -1, 0, 1, -1, 0};
        // 对应技巧1，第一次遍历，把需要变化状态的位置保存为中间值
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[0].length; j++) {
                int curX, curY;
                int live = 0;
                // 对应技巧2，通过之前保存的相对坐标偏移的数组，方便的遍历所有的周边位置。
                for (int k = 0; k < 8; k++) {
                    curX = i + x[k];
                    curY = j + y[k];
                    if (curX < 0 || curX >= board.length || curY < 0 || curY >= board[0].length) {
                        continue;
                    }
                    // 对应技巧1,这里的0,1是题目里合理的值，然后如果0要变1，我们用中间值-1记录，如果1要变0
                    // ，我们用中间值2来记录。
                    if (board[curX][curY] == 1 || board[curX][curY] == 2) {
                        live++;
                    }
                }
                if (board[i][j] == 0) {
                    if (live == 3) {
                        board[i][j] = -1;
                    }
                } else {
                    if (live < 2 || live > 3) {
                        board[i][j] = 2;
                    }
                }
            }
        }
        // 对应技巧1，第二次遍历，把中间值-1和2刷新为1和0
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[0].length; j++) {
                if (board[i][j] == 2) {
                    board[i][j] = 0;
                } else if (board[i][j] == -1) {
                    board[i][j] = 1;
                }
            }
        }
    }
}
'''


# 使用额外的状态保存，就不用使用一个额外的数组遍历了，直接在数组中改变状态
# 0->1 即原来是死，现在是活，当前状态变成3
# 1->0 即原来是活，现在是死，当前状态变成-1
'''
遍历 board 中的细胞。

根据数组的细胞状态计算新一轮的细胞状态，这里会用到能同时代表过去状态和现在状态的复合状态。

具体的计算规则如下所示：

规则 1：如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡。这时候，将细胞值改为 -1，代表这个细胞过去是活的现在死了；

规则 2：如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活。这时候不改变细胞的值，仍为 1；

规则 3：如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡。这时候，将细胞的值改为 -1，代表这个细胞过去是活的现在死了。可以看到，因为规则 1 和规则 3 下细胞的起始终止状态是一致的，因此它们的复合状态也一致；

规则 4：如果死细胞周围正好有三个活细胞，则该位置死细胞复活。这时候，将细胞的值改为 2，代表这个细胞过去是死的现在活了。

根据新的规则更新数组；

现在复合状态隐含了过去细胞的状态，所以我们可以在不复制数组的情况下完成原地更新；

对于最终的输出，需要将 board 转成 0，1 的形式。因此这时候需要再遍历一次数组，将复合状态为 2 的细胞的值改为 1，复合状态为 -1 的细胞的值改为 0。
'''


# 核心思路即两边遍历，第一遍用一个中间状态改变原来的状态
# 1 为活细胞（live）, 0 即为死细胞 (dead)
# 0->-1 记录状态为 -1  死亡->活
# 1->0  记录状态为 2   活->死亡
from typing import List
class Solution:
    def gameOfLife(self, board: List[List[int]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        # 周围的8个状态
        collections = [[-1,0],[-1,1],[0,1],[1,1],[1,0],[1,-1],[0,-1],[-1,-1]]
        if not board or not board[0]:
            return
        # 第一次遍历
        m = len(board)
        n = len(board[0])
        for i in range(m):
            for j in range(n):
                live = 0
                for di in collections:
                    x = i + di[0]
                    y = j + di[1]
                    if not (x >= 0 and x < m and y >= 0 and y < n):
                        continue
                    # 注意这里的board[i][j] == 2表示原来的状态是1即活细胞
                    if board[x][y] == 1 or board[x][y] == 2:
                        live += 1
                # 死细胞周围正好有三个活细胞，则该位置死细胞复活 表示为0->1
                if board[i][j] == 0:
                    if live == 3:
                        board[i][j] = -1
                # 如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡 表示为1->0
                elif live < 2 or live > 3:
                        board[i][j] = 2
        # 第二次遍历 恢复
        for i in range(m):
            for j in range(n):
                if board[i][j] == -1:
                    board[i][j] = 1
                elif board[i][j] == 2:
                    board[i][j] = 0

Solution().gameOfLife([[0,1,0],[0,0,1],[1,1,1],[0,0,0]])