    异或^:
    1.
        与 1 异或   n ^ 1
            异或之后 =======> 奇数+1，偶数-1
            异或之后 =======> 奇数=>偶数，偶数=>奇数
            0^1=1 , 1^1=0 ,2^1=3 ,3^1=2 ，以此类推
            可以判断奇偶性
    2.
        交换两个数
            a ^ a = 0
            swap(a,b)
            a = a ^ b
            b = b ^ a
            a = a ^ b
    3.
        a ^ b ^ b = a
        两个相同的数异或之后的结果是 0，
        而任意数和 0 进行异或的结果是它本身
    4.
        负数 ^ 负数 =====> >=0
        正数 ^ 负数 =======> <0
        '''
            以 3 ^ （-2）为例
             
            3 的补码：0000 0011
            -2的补码：1111 1110
             
            异或：    1111 1101  此为结果的补码，然后要反过来计算原码
             
            由 原码 -> 取反 -> +1 补码  得 补码 -1 -> 取反 -> 原码
             
            补码：    1111 1101
            -1 ：     1111 1100
            原码：    1000 0011
            即结果为 -3
        '''



# 任何一个数于自己异或，值为0，0……
# 计算每一位出现1的次数，然后与len-次数相乘，然后求和

# 注意这里的 n^(n-1) 的作用,可以计算两个数对应的位不同的数量

# 注意这里 n&(n-1) 的作用，因为 n&(n - 1)可以消除最后一个 1，所以可以用一个循环不停地消除 1 同时计数，直到 n 变成 0 为止。

# n ^ n & (n - 1) ======> n & -n
# 注意上面这段代码，n ^ n & (n - 1)
这样可以在先消除了最右边的1之后，然后与之前的数字相异或
就可以得到转换为二进制之后的数字最右边为1的位置对应为int时的值

# 比如n = 1001  1001 & 1000 = 1000 此时消除了最右边的1,1001^1000 = 1 
# 然后n &= n-1之后，n=1000, 1000 & 0111 = 0000,1000^0000 = 8
    4.
        计算两个数的汉明距离
            '''
            输入: x = 1, y = 4

            输出: 2

            解释:
            1   (0 0 0 1)
            4   (0 1 0 0)
                   ↑   ↑
            上面的箭头指出了对应二进制位不同的位置。
            求位置不同的数量
            '''
            -- return bin(x^y).count("1")
    5.
        两个数 a ^ b,则表示两个数无进位相加的结果
        两个数 a & b,则表示两个数的进位
    6.
        异或运算的性质
        解决这个问题，我们首先需要利用异或运算的一个性质：
        如果 a ^ b = c 成立，那么a ^ c = b 与 b ^ c = a 均成立。
        即 如果有三个数，满足其中两个数的异或值等于另一个值，那么这三个数的顺序可以任意调换。
        （说明：利用这条性质，可以不使用第 3 个变量而交换两个变量的值。）
        那么如何理解这个性质呢？因为异或运算 ^ 其实就是 二进制下不进位的加法

作者：liweiwei1419
链接：https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/solution/li-yong-yi-huo-yun-suan-de-xing-zhi-tan-xin-suan-f/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

作者：liweiwei1419
链接：https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/solution/li-yong-yi-huo-yun-suan-de-xing-zhi-tan-xin-suan-f/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

与&:
    1.
        n & (n-1)
        这个操作是算法中常见的，作用是消除数字 n 的二进制表示中的最后一个 1
        案例:
            求一个数中1的个数
    2.
        判断奇偶性质
        n & 1
        可以判断数字 n 的最后一位是1还是0,如果是0，则说明是偶数，如果是1，则是奇数
    3.
        n & -n =========> n ^ (n & (n-1))

移位 >>:
    1.
        n >> 1
        这个操作表示向右移一位，即去掉最低位

其他:

    1.
        对于所有的数字，只有两类：

        奇数：二进制表示中，奇数一定比前面那个偶数多一个 1，因为多的就是最低位的 1。
                  举例：
                 0 = 0       1 = 1
                 2 = 10      3 = 11
        偶数：二进制表示中，偶数中 1 的个数一定和除以 2 之后的那个数一样多。因为最低位是 0，除以 2 就是右移一位，也就是把那个 0 抹掉而已，所以 1 的个数是不变的。
                   举例：
                  2 = 10       4 = 100       8 = 1000
                  3 = 11       6 = 110       12 = 1100
        另外，0 的 1 个数为 0，于是就可以根据奇偶性开始遍历计算了。

        i % 2 = 1 =====> i & 1 = 1======>即最低位是1，表明是偶数
        i % 2 = 0 =====> i & 1 = 0======>即最低位是0，表示是奇数
    2.
        对于任何数字
        n ^ n & (n - 1) ======> n & -n
        表示对应的最右边为1的十进制数
    3.
        对于任何数字异或  n ^ m 必定不为0
        (n ^ m) & (- n ^ m) ======> 对应的最右边为1的十进制数，即 n 和 m 有区别的二进制位对应的十进制
    4.
        对应任何数字 n
        n & 一个十进制数字
        比如 n & 1 表示n的最后一位是0还是不是0
            n & 8 表示n的倒数第4位是0还是不是0
    5.
        int的范围 [-2^31 2^31-1] ======>[-1 << 31,1<<31-1]

