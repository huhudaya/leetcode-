'''
给定范围 [m, n]，其中 0 <= m <= n <= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。

示例 1: 

输入: [5,7]
输出: 4
示例 2:

输入: [0,1]
输出: 0
'''
'''
只要有0，与的结果就是0
如果 m < n，也就是参与相与的数字的个数至少有两个，所以一定会有 0 的出现，所以相与结果一定是 0。
因为m < n，所以在 m 到 n 之间一定有两个不同的数字，所以最低位一定与的结果一定是0，因为只要有0，与的结果就是0
看具体的例子，[5,7]。
最低位序列从 1 开始递增, 也就是最右边的一列 101
m 5 1 0 1
  6 1 1 0
n 7 1 1 1
        0
此时 m < n，所以至少会有两个数字，所以最低位相与结果一定是 0。
解决了最低位的问题，我们只需要把 m 和 n 同时右移一位。然后继续按照上边的思路考虑新的最低位的结果即可。
而当 m == n 的时候，很明显，结果就是 m 了。
代码中，我们需要用一个变量 zero 记录我们右移的次数，也就是最低位 0 的个数。
'''

# 对于任意一个数 n，然后 n & (n-1) 的结果就是把 n 的最右边的 1 置为 0
class Solution:
    def rangeBitwiseAnd(self, m: int, n: int) -> int:
        while m < n:
            # turn off rightmost 1-bit
            n = n & (n - 1)
        return m & n

# 如果 m < n，也就是参与相与的数字的个数至少有两个，所以一定会有 0 的出现，所以相与结果一定是 0
# m < n，所以至少会有两个数字，所以最低位相与结果一定是 0
# 解决了最低位的问题，我们只需要把 m 和 n 同时右移一位。然后继续按照上边的思路考虑新的最低位的结果即可。
# 因为 只要有一个0，那么无论有多少个 1都是 0
#
# 比如：从 5到 7
#
#
# 5:0 1 0 1
# 6:0 1 1 0
# 7:0 1 1 1
# -----------
#   0 1 0 0
# 其实本题就是考虑一下m的右边有多少位为1！然后向右移位就是最后的结果
class Solution:
    def rangeBitwiseAnd(self, m: int, n: int) -> int:
        shift = 0
        # find the common 1-bits
        while m < n:
            m = m >> 1
            n = n >> 1
            shift += 1
        return m << shift