# 221. 最大正方形.py
'''
在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。

示例:

输入: 

1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0

输出: 4
链接：https://leetcode-cn.com/problems/maximal-square
'''
'''
题目给定一个字符矩阵，字符矩阵中只有两种字符，分别是 ‘0’ 和 ‘1’，题目要在矩阵中找全为 ‘1’ 的，面积最大的正方形。

刚拿道这道题，如果不说任何解法的话，其实并不是特别好想，我们先来看看切题的思路是怎么样的。

首先一个正方形是由四个顶点构成的，如果说我们在矩阵中随机找四个点
然后判断该四个点组成的是不是正方形，如果是正方形
然后看组成正方形的每个位置的元素是不是都是 ‘1’，这种方式也是可行的，但是比较暴力，这么弄下来，时间复杂度是 O((m*n)^4)。

那我们就会思考，组成一个正方形是不是必须要四个点都找到？如果我们找出其中的三个点，甚至说两个点，能不能确定这个正方形呢？

你会发现，这里我们只需要考虑 正方形对角线的两个点 即可，这两个点确定了，另外的两个点也就确定了
因此我们可以把时间复杂度降为 O((m*n)^2)。

但是这里还是会有一些重复计算在里面，我们和之前一样，本质还是在做暴力枚举，只是说枚举的个数变少了
我们能不能记录我们之前得到过的答案，通过牺牲空间换取时间呢，这里正是动态规划所要做的事情！

问题拆解

我们可以思考，如果我们从左到右，然后从上到下遍历矩阵
假设我们遍历到的当前位置是正方形的右下方的点
那其实我们可以看之前我们遍历过的点有没有可能和当前点组成符合条件的正方形
除了这个点以外，无非是要找另外三个点，这三个点分别在当前点的上方，左方，以及左上方
也就是从这个点往这三个方向去做延伸，具体延伸的距离是和其相邻的三个点中的状态有关

状态定义

因为我们考虑的是正方形的右下方的顶点，因此状态可以定义成 “当前点为正方形的右下方的顶点时，正方形的最大面积”

递推方程

有了状态，我们再来看看递推方程如何写，前面说到我们可以从当前点向三个方向延伸
我们看相邻的位置的状态，这里我们需要取三个方向的状态的最小值才能确保我们延伸的是全为 ‘1’ 的正方形，也就是

dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1

实现

在实现上，我们需要单独考虑两种情况，就是当前位置是 ‘1’，还有就是当前位置是 ‘0’
如果是 ‘0’ 的话，状态就是 0，表示不能组成正方形
如果是 ‘1’ 的话，我们也需要考虑位置，如果是第一行的元素
以及第一列的元素，表明该位置无法同时向三个方向延伸，状态直接给为 1 即可，其他情况就按我们上面得出的递推方程来计算当前状态。

参考代码
public int maximalSquare(char[][] matrix) {
    if (matrix.length == 0 || matrix[0].length == 0) {
        return 0;
    }

    int m = matrix.length, n = matrix[0].length;

    int[][] dp = new int[m][n];

    int maxLength = 0;

    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            if (matrix[i][j] == '1') {
                if (i == 0 || j == 0) {
                    dp[i][j] = matrix[i][j] == '1' ? 1 : 0;
                } else {
                    dp[i][j] = Math.min(dp[i - 1][j], 
                                        Math.min(dp[i][j - 1], dp[i - 1][j - 1])) + 1;
                }

                maxLength = Math.max(dp[i][j], maxLength);
            }
        }
    }

    return maxLength * maxLength;
}
'''
import sys
from typing import List


class Solution:
    def countSquares(self, matrix: List[List[int]]) -> int:
        if not matrix or not matrix[0]:
            return -1
        m = len(matrix)
        n = len(matrix[0])
        # dp[i][j]定义为以(i, j)作为右下角的元素的正方形的个数
        dp = [[0] * (n) for i in range(m)]
        res = 0
        for i in range(m):
            for j in range(n):
                if matrix[i][j] == 1:
                    # basecase
                    if i == 0 or j == 0:
                        dp[i][j] = 1
                    else:
                        dp[i][j] = min(dp[i-1][j], dp[i-1][j-1], dp[i][j-1]) + 1
                    res += dp[i][j]
        return res
