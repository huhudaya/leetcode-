'''
编写一个程序，找出第 n 个丑数。

丑数就是质因数只包含 2, 3, 5 的正整数。

示例:

输入: n = 10
输出: 12
解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。
说明:  


# 重要条件
    1. 1 是丑数。
    2. n 不超过1690。
'''

# nlogn
class Solution:
    def nthUglyNumber(self, n: int) -> int:
        import heapq
        heap = [1]
        heapq.heapify(heap)
        res = 0
        for _ in range(n):
            # 每次弹出一个，然后和当前值进行比较，如果相等，就继续弹出，避免值的重复
            res = heapq.heappop(heap)
            while heap and res == heap[0]:
                res = heapq.heappop(heap)
            a, b, c = res * 2, res * 3, res * 5
            for t in [a, b, c]:
                heapq.heappush(heap, t)
        return res



# 小顶堆的方法是先存再排，dp的方法则是先排再存
# dp[i] 表示第i个丑数
# 那么dp[i] = min(2 * dp[l_2], 3 * dp[l_3], 5 * dp[l_5])
# 这里 l_2, l_3, l_5是表示，指到的位置
# O(N)的算法
'''
我们知道丑数序列是 1, 2, 3, 4, 5, 6, 8, 9...。

我们所有的丑数都是通过之前的丑数乘以 2, 3, 5 生成的，所以丑数序列可以看成下边的样子。

1, 1×2, 1×3, 2×2, 1×5, 2×3, 2×4, 3×3...。

我们可以把丑数分成三组，用丑数序列分别乘 2, 3, 5 。


乘 2: 1×2, 2×2, 3×2, 4×2, 5×2, 6×2, 8×2,9×2,…
乘 3: 1×3, 2×3, 3×3, 4×3, 5×3, 6×3, 8×3,9×3,…
乘 5: 1×5, 2×5, 3×5, 4×5, 5×5, 6×5, 8×5,9×5,…
我们需要做的就是把上边三组按照顺序合并起来。

合并有序数组的话，可以通过归并排序的思想，利用三个指针，每次找到三组中最小的元素，然后指针后移。

当然，最初我们我们并不知道丑数序列，我们可以一边更新丑数序列，一边使用丑数序列。


在最小堆方法中，我们的思路是把当前丑数能生成的丑数都加入到堆中，然后再弹出最小值。
如果我们能知道下一个最小的丑数，每次只生成最小的那个，就可以节省最小值查询的时间消耗。
采用动态规划的方法，用一个有序数组dp记录前n个丑数。
三个指针l2，l3和l5指向dp中的元素，最小的丑数只可能出现在dp[l2]的2倍、dp[l3]的3倍和dp[l5]的5倍三者中间。
通过移动三个指针，就能保证生成的丑数是有序的。

实际上pi的含义是有资格同i相乘的最小丑数的位置。
这里资格指的是：
如果一个丑数nums[pi]通过乘以i可以得到下一个丑数
那么这个丑数nums[pi]就永远失去了同i相乘的资格（没有必要再乘了）
我们把pi++让nums[pi]指向下一个丑数即可
'''
class Solution:
    def nthUglyNumber(self, n: int) -> int:
        dp = [0] * n
        dp[0] = 1
        # 准备三个指针
        l_2 = 0
        l_3 = 0
        l_5 = 0
        for i in range(1, n):
            dp[i] = min(2 * dp[l_2], 3 * dp[l_3], 5 * dp[l_5])
            if dp[i] >= 2 * dp[l_2]:
                l_2 += 1
            if dp[i] >= 3 * dp[l_3]:
                l_3 += 1
            if dp[i] >= 5 * dp[l_5]:
                l_5 += 1
        return dp[-1]

print(Solution().nthUglyNumber(10))

'''
不懂的话举例说明：

一开始，丑数只有{1}，1可以同2，3，5相乘，取最小的1×2=2添加到丑数序列中。

现在丑数中有{1，2}，在上一步中，1已经同2相乘过了，所以今后没必要再比较1×2了，我们说1失去了同2相乘的资格。

现在1有与3，5相乘的资格，2有与2，3，5相乘的资格，但是2×3和2×5是没必要比较的，因为有比它更小的1可以同3，5相乘，所以我们只需要比较1×3，1×5，2×2。

依此类推，每次我们都分别比较有资格同2，3，5相乘的最小丑数，选择最小的那个作为下一个丑数，假设选择到的这个丑数是同i（i=2，3，5）相乘得到的，所以它失去了同i相乘的资格，把对应的pi++，让pi指向下一个丑数即可。
'''