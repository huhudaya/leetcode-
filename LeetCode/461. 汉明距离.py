# 461. 汉明距离.py
'''

两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。

给出两个整数 x 和 y，计算它们之间的汉明距离。

注意：
0 ≤ x, y < 231.

示例:

输入: x = 1, y = 4

输出: 2

解释:
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑

上面的箭头指出了对应二进制位不同的位置。

'''
'''
      # 先将两个数异或运算得到n，那么n里面1的个数就是结果，
      # 如果n不为0，那么n至少有一位是1。如果n减1
      # 那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1。
      # 其余所有位将不会受到影响。
      # 这样右边这部分的&运算结果就为0，然后循环

        # int n=x^y;
        # int count=0;
        # while(n!=0){
        #   count++;
        #   n=n&(n-1);
        # }
        # return count;
'''
# 采用位运算
# print(bin(7).count("1"))
# res = 3

# *的作用是将多个元素放在一个元祖中
'''
汉明距离等于两个数二进制表示中对应位置不同的数量。
假设数组中的每个数都表示为 k 位的二进制数（高位补 0），那么我们可以发现，要计算数组中任意两个数的汉明距离的总和，可以先算出数组中任意两个数二进制第 i 位的汉明距离的总和，在将所有的 k 位之和相加。也就是说，二进制中的每一位都是可以独立计算的。

因此，我们考虑数组中每个数二进制的第 i 位，假设一共有 t 个 0 和 n - t 个 1，那么显然在第 i 位的汉明距离的总和为 t * (n - t)。

由于所有的数都在 [0, 10^9] 的范围内，因此 k 最大为 31。我们只要计算出每一位上的汉明距离的总和，再相加即可。
'''
# 技巧版本
def totalHammingDistance(nums):
    return sum((b.count('0') * b.count('1')) for b in zip(*map('{:032b}'.format, nums)))

# a = *map('{:032b}'.format, [1,2,4])
print(list(zip(list(map('{:032b}'.format, [1,2,4])))))
print(*map('{:032b}'.format, [1,2,4]))

# print(a)

# 00000000000000000000000000000001 00000000000000000000000000000010 00000000000000000000000000000100

# 任何一个数于自己异或，值为0，0……
# 计算每一位出现1的次数，然后与len-次数相乘，然后求和
# 注意这里的n^(n-1)的作用,可以计算两个数对应的位不同的数量
# 注意这里n&(n-1)的作用，因为 n&(n - 1)可以消除最后一个 1，所以可以用一个循环不停地消除 1 同时计数，直到 n 变成 0 为止。
import collections
class Solution:
    def totalHammingDistance(self, nums) -> int:
        l, d = len(nums), collections.defaultdict(int)
        for n in nums:
            # while n != 0:
            # 对每一个数字n,进行循环判断，判断这个数字转换为二进制之后相应位置是1还是0，对相应的map进行增加。判断是否为0，当终止时候，二进制的所有位数都变成0
            while n:
                # 计数，计算0和1对应的数量
                d[n ^ n & (n - 1)] += 1
                # 不停消除最右边位置的1
                n &= n - 1 
            print(d)
        return sum(c * (l - c) for _, c in d.items())
print(Solution().totalHammingDistance([1,9,191]))

# 注意上面这段代码，n ^ n & (n - 1)，这样可以在先消除了最右边的1之后，然后与之前的数字相异或，就可以得到转换为二进制之后的数字最右边为1的位置对应为int时的值
# 比如n = 1001  1001 & 1000 = 1000 此时消除了最右边的1,1001^1000 = 1 
# 然后n &= n-1之后，n=1000, 1000 & 0111 = 0000,1000^0000 = 8

print(bin(0^4))