'''
你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。
每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。
你知道存在楼层 F ，满足 0 <= F <= N 任何从高于 F 的楼层落下的鸡蛋都会碎
从 F 楼层或比它低的楼层落下的鸡蛋都不会破。
每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 <= X <= N）。
你的目标是确切地知道 F 的值是多少。
无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？

示例 1：
输入：K = 1, N = 2
输出：2

解释：
鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。
否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。
如果它没碎，那么我们肯定知道 F = 2 。
因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。

示例 2：
输入：K = 2, N = 6
输出：3

示例 3：
输入：K = 3, N = 14
输出：4

提示：
1 <= K <= 100
1 <= N <= 10000
'''
'''
这个算法的时间复杂度是多少呢？动态规划算法的时间复杂度就是子问题个数 × 函数本身的复杂度

函数本身的复杂度就是忽略递归部分的复杂度，这里dp函数中有一个 for 循环，所以函数本身的复杂度是 O(N)

子问题个数也就是不同状态组合的总数，显然是两个状态的乘积，也就是 O(KN)

所以算法的总时间复杂度是 O(K*N^2), 空间复杂度为子问题个数，即 O(KN)
'''
# 这道题最重要的特性就是如果不超过特定楼层，鸡蛋是不会碎的
# 以某种策略进行测试的时候，以这种策略看最坏情况下，你至少要扔几次鸡蛋，才能确定这个楼层F呢？
# 这就相当于求res = min(bad(k,n),res)  相当于求最好的策略下最坏的结果

# 「状态」很明显，就是当前拥有的鸡蛋数K和需要测试的楼层数N。随着测试的进行，鸡蛋个数可能减少，楼层的搜索范围会减小，这就是状态的变化。
# 「选择」其实就是去选择哪层楼扔鸡蛋。
'''
现在明确了「状态」和「选择」，动态规划的基本思路就形成了
：肯定是个二维的dp数组或者带有两个状态参数的dp函数来表示状态转移；
外加一个 for 循环来遍历所有选择，择最优的选择更新结果 ：

# 当前状态为 (K 个鸡蛋，N 层楼)
# 返回这个状态下的最优结果
def dp(K, N):
    int res
    for 1 <= i <= N:
        res = min(res, 这次在第 i 层楼扔鸡蛋)
    return res

'''
def superEggDrop(K: int, N: int):

    memo = dict()
    def dp(K, N) -> int:
        # base case
        if K == 1:
            return N
        if N == 0:
            return 0
        # 避免重复计算
        if (K, N) in memo:
            return memo[(K, N)]

        res = float('INF')
        # 穷举所有可能的选择，相当于是策略，穷举所有的策略，找对最好的策略下最坏的结果
        # 因为我们要求的是最坏情况下扔鸡蛋的次数，所以鸡蛋在第i层楼碎没碎，取决于那种情况的结果更大：
        # 第一次遍历的时候实际上是确定第一次在哪一层楼扔鸡蛋，然后再次递归的遍历，找到最好的策略下最坏的结果
        for i in range(1, N + 1):
            # 最好的策略下最坏的情况扔鸡蛋次数，相当于比较所有的最坏的结果，取最好的
            res = min(res,
                      # 最坏的情况下
                      max(
                          dp(K - 1, i - 1),  # 碎
                          dp(K, N - i)  # 没碎
                      ) + 1  # 在第 i 楼扔了一次
            )
        return res
        # 记入备忘录
        memo[(K, N)] = res
        return res
    return dp(K, N)


'''
你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。
每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。
你知道存在楼层 F ，满足 0 <= F <= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。
每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 <= X <= N）。
你的目标是确切地知道 F 的值是多少。
无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？

示例 1：
输入：K = 1, N = 2
输出：2

解释：
鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。
否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。
如果它没碎，那么我们肯定知道 F = 2 。
因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。

示例 2：
输入：K = 2, N = 6
输出：3

示例 3：
输入：K = 3, N = 14
输出：4

提示：
1 <= K <= 100
1 <= N <= 10000
'''
'''
这个算法的时间复杂度是多少呢？动态规划算法的时间复杂度就是子问题个数 × 函数本身的复杂度

函数本身的复杂度就是忽略递归部分的复杂度，这里dp函数中有一个 for 循环，所以函数本身的复杂度是 O(N)

子问题个数也就是不同状态组合的总数，显然是两个状态的乘积，也就是 O(KN)

所以算法的总时间复杂度是 O(K*N^2), 空间复杂度为子问题个数，即 O(KN)
'''
# 这道题最重要的特性就是如果不超过特定楼层，鸡蛋是不会碎的
# 以某种策略进行测试的时候，以这种策略看最坏情况下，你至少要扔几次鸡蛋，才能确定这个楼层F呢？
# 这就相当于求res = min(bad(k,n),res)  相当于求最好的策略下最坏的结果

# 「状态」很明显，就是当前拥有的鸡蛋数K和需要测试的楼层数N。随着测试的进行，鸡蛋个数可能减少，楼层的搜索范围会减小，这就是状态的变化。
# 「选择」其实就是去选择哪层楼扔鸡蛋。
'''
现在明确了「状态」和「选择」，动态规划的基本思路就形成了
：肯定是个二维的dp数组或者带有两个状态参数的dp函数来表示状态转移；
外加一个 for 循环来遍历所有选择，择最优的选择更新结果 ：

# 当前状态为 (K 个鸡蛋，N 层楼)
# 返回这个状态下的最优结果
def dp(K, N):
    int res
    for 1 <= i <= N:
        res = min(res, 这次在第 i 层楼扔鸡蛋)
    return res

'''
# https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484690&idx=1&sn=eea075701a5d96dd5c6e3dc6a993cac5&chksm=9bd7fb1aaca0720c58c9d9e02a8b9211a289bcea359633a95886d7808d2846898d489ce98078&scene=21#wechat_redirect
# 二分搜索优化
def superEggDrop(K: int, N: int):

    memo = dict()
    def dp(K, N) -> int:
        # base case
        if K == 1:
            return N
        if N == 0:
            return 0
        # 避免重复计算
        if (K, N) in memo:
            return memo[(K, N)]

        # 穷举所有可能的选择，相当于是策略，穷举所有的策略，找对最好的策略下最坏的结果
        # 因为我们要求的是最坏情况下扔鸡蛋的次数，所以鸡蛋在第i层楼碎没碎，取决于那种情况的结果更大：
        # 第一次遍历的时候实际上是确定第一次在哪一层楼扔鸡蛋，然后再次递归的遍历，找到最好的策略下最坏的结果
        # 用二分搜索代替线性搜索
        res = float('INF')
        # 用二分搜索代替线性搜索
        lo, hi = 1, N
        while lo <= hi:
            mid = (lo + hi) // 2
            broken = dp(K - 1, mid - 1) # 碎
            not_broken = dp(K, N - mid) # 没碎
            # res = min(max(碎，没碎) + 1)
            if broken > not_broken:
                hi = mid - 1
                res = min(res, broken + 1)
            else:
                lo = mid + 1
                res = min(res, not_broken + 1)

        memo[(K, N)] = res
        return res
    return dp(K, N)
print(float("INF"))


import sys
class Solution:
    def superEggDrop(self, K: int, N: int) -> int:
        # 迭代
        @functools.lru_cache(None)
        def dp(k, n):
            res = sys.maxsize
            if k == 1:
                return n
            if n == 0:
                return 0
            for i in range(1, n + 1):
               res = min(res, max(dp(k - 1, i - 1), dp(k, n - i)) + 1)
            return res
        return dp(K, N)



