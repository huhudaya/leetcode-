1.JDK和JRE的区别

2.java的基本数据类型
    数据类型	大小
    byte(字节)	1个字节(8位)
    shot(短整型) 	2个字节(16位)
    int(整型)	4个字节(32位)
    long(长整型) 	8个字节(32位)
    float(浮点型)	4个字节(32位)
    double(双精度)	8个字节(64位)
    char(字符型)	2个字节(16位)
    boolean(布尔型)	1位
    附加：
     String是基本数据类型吗?(String不是基本数据类型)
     String的长度是多少，有限制?(长度受内存大小的影响)

3.创建线程的方式
    浅谈三种方式优劣势
    通过继承Thread类或实现Runnable、Callable接口都可以实现多线程，不过实现Runnable接口与实现Callable接口的方式基本相同，只是Callable接口里定义的方法有返回值，可以声明抛出异常而已。因此可以将实现Runnable接口和实现Callable接口归为一种方式。这种方式与继承Thread方式之间的主要差别如下。
    1.采用实现Runnable、Callable接口的方式创建多线程的优缺点：
优势：（1）线程类只是实现了Runnable接口与Callable接口，还可以继承其他类。
     （2）在这种方式下，多个线程可以共享一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。
劣势：编程稍稍复杂，如果需要访问当前线程，则必须使用Thread.currentThread（）方法。
    2.采用继承Thread类的方法创建多线程的优缺点：
劣势：因为线程类已经继承了Thread类，所以不能再继承其他父类。
优势：编写简单，如果需要访问当前线程，则无须使用Thread.currentThread（）方法，直接使用this即可获得当前线程。
五、总结
    鉴于上面分析，因此一般推荐采用实现Runnable接口、Callable接口的方式来创建多线程。

4.什么是死锁
    线程死锁是指由于两个或者多个线程互相持有对方所需要的资源，导致这些线程处于等待状态，无法前往执行。当线程进入对象的synchronized代码块时，便占有了资源，直到它退出该代码块或者调用wait方法，才释放资源，在此期间，其他线程将不能进入该代码块。当线程互相持有对方所需要的资源时，会互相等待对方释放资源，如果线程都不主动释放所占有的资源，将产生死锁。

当然死锁的产生是必须要满足一些特定条件的：
1.互斥条件：进程对于所分配到的资源具有排它性，即一个资源只能被一个进程占用，直到被该进程释放
2.请求和保持条件：一个进程因请求被占用资源而发生阻塞时，对已获得的资源保持不放。
3.不剥夺条件：任何一个资源在没被该进程释放之前，任何其他进程都无法对他剥夺占用
4.循环等待条件：当发生死锁时，所等待的进程必定会形成一个环路（类似于死循环），造成永久阻塞。

5.java中class.forName和classLoader加载类的区分
    总结
        ClassLoader.load()方法加载一个类的时候不会触发这个类初始化（有关类初始化的相关内容请查看我的另外一篇详细的介绍）
        自然static静态代码块就不会被执行
        Class.forName()方法加载一个类之后会强制这个类初始化
     java中class.forName和classLoader都可用来对类进行加载。
     前者除了将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块。
     而classLoader只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。Class.forName(name, initialize, loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象

        下面说一下两者具体的执行过程
    1.LoadClass（）方法加载类及初始化过程：
        类加载（loadclass（））（加载）——》newInstance（）（链接+初始化）
        newInstance（）:
        （开始连接）静态代码块——》普通变量分配准备（a=0;b=0;c=null）——》（开始初始化）普通变量赋值（a=1;b=2;c=”haha”）——》构造方法——》初始化成功。

    2.Class.forName(Stirng className)一个参数方法加载类及初始化过程：
        类加载(Class.forName())（加载）——》静态代码块——》newInstance（）（链接+初始化）

    newInstance（）：
        （开始连接）普通变量分配准备（a=0;b=0;c=null）——》（开始初始化）普通变量赋值（a=1;b=2;c=”haha”）——》构造方法——》初始化成功。


6.谈谈RDD
    1为什么会产生RDD
（1） 传统的MapReduce虽然具有自动容错、平衡负载和可拓展性的优点，但是其最大缺点是采用非循环式的数据流模型，使得在迭代计算式要进行大量的磁盘IO操作。RDD正是解决这一缺点的抽象方法。
（2） RDD是Spark提供的最重要的抽象的概念，它是一种有容错机制的特殊集合，可以分布在集群的节点上，以函数式编操作集合的方式，进行各种并行操作。可以将RDD理解为一个具有容错机制的特殊集合，它提供了一种只读、只能有已存在的RDD变换而来的共享内存，然后将所有数据都加载到内存中，方便进行多次重用。

    a. 他是分布式的，可以分布在多台机器上，进行计算。
    b. 他是弹性的，计算过程中内存不够时它会和磁盘进行数据交换。
    c. 这些限制可以极大的降低自动容错开销
    d. 实质是一种更为通用的迭代并行计算框
    （1）为什么会有Spark？因为传统的并行计算模型无法有效的解决迭代计算（iterative）和交互式计算（interactive）；而Spark的使命便是解决这两个问题，这也是他存在的价值和理由。
    （2）Spark如何解决迭代计算？其主要实现思想就是RDD，把所有计算的数据保存在分布式的内存中。迭代计算通常情况下都是对同一个数据集做反复的迭代计算，数据在内存中将大大提升IO操作。这也是Spark涉及的核心：内存计算。
    （3）Spark如何实现交互式计算？因为Spark是用scala语言实现的，Spark和scala能够紧密的集成，所以Spark可以完美的运用scala的解释器，使得其中的scala可以向操作本地集合对象一样轻松操作分布式数据集。
    （4）Spark和RDD的关系？可以理解为：RDD是一种具有容错性基于内存的集群计算抽象方法，Spark则是这个抽象方法的实现。


https://blog.csdn.net/qq_22771739/article/details/82529874
问：Java 线程优先级是怎么定义的，Java 线程有几种状态？
    答：Java 线程的优先级定义为从 1 到 10 的等级，默认为 5，设置和获取线程优先级的方法是 setPriority(int newPriority) 和 getPriority()，Java 的这个优先级会被映射到操作系统中线程的优先级，不过由于操作系统各不相同，不一定都是 10 个优先级，所以 Java中不同的优先级可能会被映射到操作系统中相同的优先级，同时优先级对操作系统而言更多的是一种建议和提示而非强制，所以我们不要过于依赖优先级。
    Java Thread 可以通过 State getState() 来获取线程状态，Thread.State 枚举定义了 NEW、RUNNABLE、BLOCKED、WAITING、TIMED_WAITING、TERMINATED 六种线程状态，其实真正严格意义来说线程只有就绪、阻塞、运行三种状态，Java 线程之所以有六种状态其实是站在 Thread 对象实例的角度来看待的，具体解释如下：
    NEW（新建），表示线程 Thread 刚被创建，还没调用 start 方法。
    RUNNABLE（运行，实质对应就绪和运行状态），表示 Thread 线程正在 JVM 中运行，也就是说处于就绪和运行状态的线程在 Thread 中都表现为 RUNNABLE。
    BLOCKED（阻塞，实质对应阻塞状态），表示等待监视锁可以重新进行同步代码块中执行，此线程需要获得某个锁才能继续执行，而这个锁目前被其他线程持有，所以进入了被动的等待状态，直到抢到了那个锁才会再次进入就绪状态。处于受阻塞状态的某一线程正在等待监视器锁，以便进入一个同步的块或方法，或者在调用 wait 之后再次进入同步的块或方法。
    WAITING（等待，实质对应阻塞状态），表示此线程正处于无限期的主动等待中，直到有人唤醒它它才会再次进入就绪状态。某一线程因为调用下不带超时值的 wait、不带超时值的 join、LockSupport.park 会进入等待状态，处于等待状态的线程正等待另一个线程以执行特定操作，例如已经在某一对象上调用了 Object.wait() 的线程正等待另一个线程以便在该对象上调用 Object.notify() 或 Object.notifyAll()，或者已经调用了 Thread.join() 的线程正在等待指定线程终止。
    TIMED_WAITING（有限等待，实质对应阻塞状态），表示此线程正处于有限期的主动等待中，要么有人唤醒它，要么等待够了一定时间之后才会再次进入就绪状态，譬如调用带有超时的 sleep、join、wait 方法可能导致线程处于等待状态。
    TERMINATED（终止），表示线程执行完毕，已经退出。

1. 初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。
2. 运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。
线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。
3.阻塞(BLOCKED)：表示线程阻塞于锁。
4.等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。
5.超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。
6. 终止(TERMINATED)：表示该线程已经执行完毕。
Java中线程的状态分为6种。

1. 初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。
2. 运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。
线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。
3.阻塞(BLOCKED)：表示线程阻塞于锁。
4.等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。
5.超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。
6. 终止(TERMINATED)：表示该线程已经执行完毕。

线程的状态图




1. 初始状态
实现Runnable接口和继承Thread可以得到一个线程类，new一个实例出来，线程就进入了初始状态。

2.1. 就绪状态
就绪状态只是说你资格运行，调度程序没有挑选到你，你就永远是就绪状态。
调用线程的start()方法，此线程进入就绪状态。
当前线程sleep()方法结束，其他线程join()结束，等待用户输入完毕，某个线程拿到对象锁，这些线程也将进入就绪状态。
当前线程时间片用完了，调用当前线程的yield()方法，当前线程进入就绪状态。
锁池里的线程拿到对象锁后，进入就绪状态。
2.2. 运行中状态
线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一一种方式。

3. 阻塞状态
阻塞状态是线程阻塞在进入synchronized关键字修饰的方法或代码块(获取锁)时的状态。

4. 等待
处于这种状态的线程不会被分配CPU执行时间，它们要等待被显式地唤醒，否则会处于无限期等待的状态。

5. 超时等待
处于这种状态的线程不会被分配CPU执行时间，不过无须无限期等待被其他线程显示地唤醒，在达到一定时间后它们会自动唤醒。

6. 终止状态
当线程的run()方法完成时，或者主线程的main()方法完成时，我们就认为它终止了。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦终止了，就不能复生。
在一个终止的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。
等待队列
调用obj的wait(), notify()方法前，必须获得obj锁，也就是必须写在synchronized(obj) 代码段内。
与等待队列相关的步骤和图
    1.线程1获取对象A的锁，正在使用对象A。
    2.线程1调用对象A的wait()方法。
    3.线程1释放对象A的锁，并马上进入等待队列。
    4.锁池里面的对象争抢对象A的锁。
    5.线程5获得对象A的锁，进入synchronized块，使用对象A。
    6.线程5调用对象A的notifyAll()方法，唤醒所有线程，所有线程进入同步队列。若线程5调用对象A的notify()方法，则唤醒一个线程，不知道会唤醒谁，被唤醒的那个线程进入同步队列。
    7.notifyAll()方法所在synchronized结束，线程5释放对象A的锁。
    8.同步队列的线程争抢对象锁，但线程1什么时候能抢到就不知道了。
同步队列状态
    当前线程想调用对象A的同步方法时，发现对象A的锁被别的线程占有，此时当前线程进入同步队列。简言之，同步队列里面放的都是想争夺对象锁的线程。
    当一个线程1被另外一个线程2唤醒时，1线程进入同步队列，去争夺对象锁。
    同步队列是在同步的环境下才有的概念，一个对象对应一个同步队列。
几个方法的比较
    1.Thread.sleep(long millis)，一定是当前线程调用此方法，当前线程进入TIMED_WAITING状态，但不释放对象锁，millis后线程自动苏醒进入就绪状态。作用：给其它线程执行机会的最佳方式。
    2.Thread.yield()，一定是当前线程调用此方法，当前线程放弃获取的CPU时间片，但不释放锁资源，由运行状态变为就绪状态，让OS再次选择线程。作用：让相同优先级的线程轮流执行，但并不保证一定会轮流执行。实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。Thread.yield()不会导致阻塞。该方法与sleep()类似，只是不能由用户指定暂停多长时间。
    3.t.join()/t.join(long millis)，当前线程里调用其它线程t的join方法，当前线程进入WAITING/TIMED_WAITING状态，当前线程不会释放已经持有的对象锁。线程t执行完毕或者millis时间到，当前线程进入就绪状态。
    4.obj.wait()，当前线程调用对象的wait()方法，当前线程释放对象锁，进入等待队列。依靠notify()/notifyAll()唤醒或者wait(long timeout) timeout时间到自动唤醒。
    5.obj.notify()唤醒在此对象监视器上等待的单个线程，选择是任意性的。notifyAll()唤醒在此对象监视器上等待的所有线程。

MYSQL查询过程:
一、执行一个查询过程概述
1.客户端发送一条查询给服务器；
2.服务器先检查查询缓存，如果命中了缓存，则立即返回存储在缓存中的结果。否则进入下一阶段；
3.服务器端进行sql解析、预处理，再由优化器生成对应的执行计划；
4.mysql根据优化器生成的执行计划，调用存储引擎的api来执行查询；
5.将结果返回给客户端；

二、查询缓存
查询缓存保存查询返回的完整结构；
命中查询缓存时，mysql会立即返回结果，跳过解析、优化和执行阶段；
查询缓存系统会跟踪查询中设计的每个表，如果这些表发生变化，和这个表相关的所有缓存数据都将失效；
判断缓存是否命中时，不会进行解析查询语句，直接使用sql语句和客户端发送过来的其他原始信息，任何字符上的不同，例如空格、注解等，都会导致缓存不命中；
当查询语句有一些不确定的数据时，则不会被缓存；
查询缓存配置参数：
query_cache_type：是否打开缓存。OFF、ON和DEMAND。DEMAND表示只有在查询语句中明确写明SQL_CACHE的语句才会放入查询缓存。eg：select sql_cache * from table_name;
query_cache_size：缓存使用的总内存空间大小，单位是字节；
query_cache_min_res_unit：分配内存块时的最小单位，较小的该值可以减少碎片导致的内存空间浪费，但会导致更频繁的内存块操作；
query_cache_limit：mysql能够缓存的最大查询结果，如果查询结果大于这个值，则不会被缓存；由于查询缓存在数据生成的时候就开始尝试缓存数据，所以当结果全部返回后，mysql才知道查询结果是否超出限制。超出之后，才会将结果从查询缓存中删除；
query_cache_wlock_invalidate：如果某个数据表被其他连接锁住，是否仍然从查询缓存中返回结果，默认OFF，表示仍然可以返回；
三、语法解析器和预处理器
mysql解析器通过关键字将sql语句进行解析，并生成对应的解析树；
mysql解析器将使用mysql语法规则验证和解析查询，eg：验证是否使用错误的关键字、使用关键字的顺序是否正确、验证引号是否前后匹配等；
预处理器根据一些mysql规则进行进一步检查解析树是否合法，eg：检查数据表和数据列是否存在，解析名字和别名是否有歧义；
下一步预处理器验证用户权限，查看用户是否有操作权限，通常很快；
四、查询优化器
优化器的作用就是找到最好的执行计划；
语法树被认为是合法后，优化器将sql语句转换为执行计划，一条查询可以有多种执行方式，最后都返回相同的结果；
生成执行计划过程
耗时较多，特别是存在许多可选的执行计划时；
在一条sql语句执行过程中将该语句对应的最终执行计划进行缓存，下一次就可以直接使用已缓存的执行计划，从而提高sql语句的执行速度；
mysql使用基于成本的优化器（CBO cost-based optimizer），会预测一个查询使用某种执行计划的成本，选择其中成本最小的一个；
优化器会根据优化规则对关系表达式进行转换，经过优化规则后会生成另一个关系表达式，原有表达式也会保留；
经过一系列转换后会生成多个执行计划，然后CBO会根据统计信息和代价模型（cost model）计算每个执行计划的cost，从中挑选cost最小的执行计划；
导致mysql优化器选择非最优执行计划的原因
mysql是根据成本计算得出的最优计划，可能执行时间并不是最短的；
有时候可能无法估算所有可能的执行计划，导致可能错过最优的执行计划；
执行计划成本估算不等同于实际执行的成本，mysql层面无法知道哪些页面在内存中，哪些在磁盘上，实际执行过程中需要多少次物理IO无法得知；
mysql不会考虑不受其控制的操作成本，eg：执行用户自定义函数的成本；
统计信息不准确，mysql依赖存储引擎提供的统计信息（每个表有多少页面、数据行和索引的长度、索引的分布等）来估计成本，InnoDB因为MVCC的架构，并不能维护一个数据表行数的精确统计信息；
mysql可以处理的优化类型
重新定义关联表的顺序；
使用等价转换原则，eg：移除一些恒成立或恒不成立的判断；
可能的表达式转换为常数表达式；
提前终止查询，使用limit；
五、查询执行引擎
查询执行引擎根据执行计划来完成整个查询；
执行计划是一个数据结构（指令树），不是和其他关系型数据库那样生成对应的字节码；
mysql根据执行计划给出的指令逐步执行，在执行过程中，有大量的操作需要调用存储引擎实现的接口来完成，这些接口即为“handler API”；
查询中每一个表由一个handler的实例表示。在优化阶段mysql就为每一个表创建了一个handler实例，优化器可以根据这些实例的接口获取表的相关信息，eg：列名、索引、统计信息等；
六、返回客户端结果
如果查询可以被缓存，mysql会在这个阶段将结果存放到查询缓存中；
mysql将结果集返回给客户端是一个增量逐步返回的过程，在查询生成第一条结果时，mysql就可以开始向客户端逐步返回结果了；
增量逐步返回的好处：服务端无须存储太多的结果，不会因为返回太多的结果而消耗太多内存；同时让客户端第一时间获得返回结果；
结果集中的每一行都会以一个满足mysql客户端/服务端通信协议的包发送，再通过tcp协议进行传输，传输过程中，可能对mysql的包进行缓存然后批量传输；


说说AQS原理吧
    AQS主要是采用volatile修饰的变量state，通过对state的CAS判断来获取锁和解锁
    如果CAS成功，就获取到锁，如果没有获取成功，线程被挂起
    并且存在等待队列和条件等待队列来park相关线程之后入队等待
    有公平和非公平两者模式来唤醒等待的线程。
    共享式和独占式两种模式
    主要是为了封装和抽象，通过封装了公共的方法，减少重复代码。


2：HashMap 的工作原理？
    HashMap 底层是 hash 数组和单向链表实现，数组中的每个元素都是链表，由 Node 内部类（实现 Map.Entry接口）实现，HashMap 通过 put & get 方法存储和获取。
    存储对象时，将 K/V 键值传给 put() 方法：
    ①、调用 hash(K) 方法计算 K 的 hash 值，然后结合数组长度，计算得数组下标；
    ②、调整数组大小（当容器中的元素个数大于 capacity * loadfactor 时，容器会进行扩容resize 为 2n）；
    ③、i.如果 K 的 hash 值在 HashMap 中不存在，则执行插入，若存在，则发生碰撞；
    ii.如果 K 的 hash 值在 HashMap 中存在，且它们两者 equals 返回 true，则更新键值对；
    iii. 如果 K 的 hash 值在 HashMap 中存在，且它们两者 equals 返回 false，则插入链表的尾部（尾插法）或者红黑树中（树的添加方式）。（JDK 1.7 之前使用头插法、JDK 1.8 使用尾插法）（注意：当碰撞导致链表大于 TREEIFY_THRESHOLD = 8 时，就把链表转换成红黑树）
    获取对象时，将 K 传给 get() 方法
    ：①、调用 hash(K) 方法（计算 K 的 hash 值）从而获取该键值所在链表的数组下标；
    ②、顺序遍历链表，equals()方法查找相同 Node 链表中 K 值对应的 V 值。
    hashCode 是定位的，存储位置；equals是定性的，比较两者是否相等。
4.你知道 hash 的实现吗？为什么要这样实现？
    JDK 1.8 中，是通过 hashCode() 的高 16 位异或低 16 位实现的：
    (h = k.hashCode()) ^ (h >>> 16)，主要是从速度，功效和质量来考虑的，减少系统的开销，也不会造成因为高位没有参与下标的计算，从而引起的碰撞。


7.HashMap中put方法的过程？
答：“调用哈希函数获取Key对应的hash值，再计算其数组下标；
如果没有出现哈希冲突，则直接放入数组；如果出现哈希冲突，则以链表的方式放在链表后面；
如果链表长度超过阀值( TREEIFY THRESHOLD==8)，就把链表转成红黑树，链表长度低于6，就把红黑树转回链表;
如果结点的key已经存在，则替换其value即可；
如果集合中的键值对大于12，调用resize方法进行数组扩容。”