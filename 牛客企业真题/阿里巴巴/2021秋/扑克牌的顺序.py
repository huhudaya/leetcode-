'''
题干：
魔术师手中有一堆扑克牌， 但是被选中观众不知道它的顺序。
第一步， 魔术师从牌顶拿出一张牌， 放到桌子上。
第二步， 魔术师从牌顶再拿一张牌， 放在手上牌的底部。
第三步， 重复第一/二步的操作， 直到魔术师手中所有的牌都放到了桌子上。
然后观众根据桌子上扑克牌的顺序说出原来魔术师刚开始手上扑克牌的顺序。
示例：

输入：nums =  [13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
输出：[1, 12, 2, 8, 3, 11, 4, 9, 5, 13, 6, 10, 7]
题目分析：
此题不难，题目已经给出了得到桌面上扑克牌顺序的规则，我们只要逆推回去就可以，比如我们逆推一下案例，总结一下逆推的规则：我们现在拿13这张牌，在取出12这张牌，直接放到13上面即可，得到[12, 13]（为什么直接放？我们设想一下按照题目规则来说，剩下两张牌的时候，[12, 13]，12取出，13自己一张牌，放底部也是13啊），在取出11这张牌，规则反着来，取出13放顶部，再将11放顶部，得到[11, 13, 12]，在取出10这张牌，规则反着来，取出12放顶部，再将10放顶部，得到[10, 12, 11, 13]，以此类推......最后得到[1, 12, 2, 8, 3, 11, 4, 9, 5, 13, 6, 10, 7]。
逆推的规则：
第一步，从手中的牌底拿出一张牌，放到手中牌的牌顶。
第二步，从桌子上牌顶拿出一张牌，放到手中牌的牌顶。
第三步， 重复第一/二步的操作， 直到桌子上所有的牌都放到了手中。
这样就得到了魔术师刚开始手上扑克牌的顺序
新手有可能遇到的解题思路陷阱：
自己根据想的案例总结规律，其实规律题目已经给出了，只需要反过来就可以。
解题思路分析以及代码实现：
第一种思路：逆推规则，利用队列的先进先出的特性，可以将先添加进入的元素取出在添加（模拟从牌尾到牌顶的过程） 。
第一种思路代码：

	private static int[] PlayingCardOrder(int[] numbers) {
		Queue<Integer> queue = new LinkedList<Integer>();
		queue.add(numbers[0]);
		queue.add(numbers[1]);
		for (int i = 2; i < numbers.length; i++) {
			queue.add(queue.poll());
			queue.add(numbers[i]);
		}
		//此时队列中的顺序是魔术师刚开始手上扑克牌的顺序的倒序
		int[] orderNumbers = new int[numbers.length];
		int i = numbers.length - 1;
		while (!queue.isEmpty()) {
			orderNumbers[i] = queue.poll();
			i--;
		}
		return orderNumbers;
	}
'''