'''
恰好装满问题
是否恰好装满的解法不同只在于初始值的不同

恰好装满：

求最大值时，除了dp[0] 为0，其他都初始化为无穷小 -0x3f3f3f3f

求最小值时，除了dp[0] 为0，其他都初始化为无穷大   0x3f3f3f3f

不必恰好装满： 全初始化为0

 

初始化的细节问题（参考：链接）

我们看到的求解最优解的背包问题中，事实上有两种不太相同的问法。 
1. 要求”背包恰好装满“ 时的最优解 
2. 不要求背包一定要被装满时的最优解

我们上面所讨论的就是第2种， 不要求背包一定要被装满时的最优解。
一种区别这两种问法的实现方法是在初始化的时候有所不不同。

如果是第一种问法，要求恰好装满背包，那么在初始化时除了 dp[0] 为0, 其他dp[1...W]均设为−∞，这样就可以保证最终得到 dp[v1]是一种恰好装满背包的最优解
如果并没有要求必须把背包装满，而是只希望价格尽量大，初始化时应该将dp[0...W} 全部设为0。 

这是为什么呢？可以这样理解：初始化的dp 数组事实上就是在没有任何物品可以放入背包时的合法状态。如果要求背包恰好装满，那么此时只有容量为0的背包可以在什么也不装的状态下被 “恰好装满” ，此时背包价值为0。其他容量的背包均没有合法的解，属于未定义的状态，所以都应该被赋值为 −∞ 。当前的合法解，一定是从之前的合法状态推得的

如果背包并非必须被装满，那么任何容量的背包都有一个合法解 “什么也不装”，这个解的价值为0,所以初始化时状态的值也就全部为0了。


'''
'''
#include<stack>
#include<queue>
#include<stdio.h>
#include<string.h>
#include<algorithm>
#define Min(a,b) a<b?a:b
using namespace std;
const int N=507;
const int maxn=10007;
int dp[maxn],w[N],v[N];//注意dp爆不爆int
int t,n,v1;
int main()
{
    scanf("%d",&t);
    while(t--)
    {                              //求最大值，初始化为无穷小
    	memset(dp,0x3f,sizeof(dp));//求最小值，初始化为无穷大
    	dp[0]=0;//恰好装满，只有背包容量为0时满足，其他初始化为无穷表示未被定义
        int i,j,w1,w2;
        scanf("%d%d",&w1,&w2);
        v1=w2-w1;
        scanf("%d",&n);
        for(i=1;i<=n;i++)
            scanf("%d%d",&w[i],&v[i]);
        for(i=1;i<=n;i++)
        {
            for(j=v[i];j<=v1;j++)//正序，放入第i物品,之前的状态需要进行改变,故需要正序
           {                    //（01背包是倒序,因为对之前的状态没影响）
                    dp[j]=Min(dp[j],dp[j-v[i]]+w[i]);
            }
        }
        if(dp[v1]==0x3f3f3f3f) //求最小值时，如果等于无穷大则不能被装满
        printf("This is impossible.\n");//求最大值时,if(dp[v1]<0)则不能被装满
        else
         printf("The minimum amount of money in the piggy-bank is %d.\n",dp[v1]);
    }
    return 0;
}
'''